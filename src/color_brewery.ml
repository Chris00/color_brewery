type color = Gg.color
type cmyk = Gg.v4

let to_hex x =
  if x <= 0. then 0
  else if x >= 1. then 0xFF
  else truncate(x *. 255. +. 0.5)

let to_int c =
  (to_hex(Gg.Color.r c) lsl 16) lor (to_hex(Gg.Color.g c) lsl 8)
  lor (to_hex(Gg.Color.b c))


let hue_pct h =
  (* h ∈ [0, 1[ instead of the usual h ∈ [0, 360[. *)
  let f, hi = modf (abs_float h *. 6.) in
  match mod_float hi 6. with
  | 0. -> Gg.Color.v 1.        f        0.       1. (* alpha = 1 *)
  | 1. -> Gg.Color.v (1. -. f)  1.       0.       1.
  | 2. -> Gg.Color.v 0.        1.       f        1.
  | 3. -> Gg.Color.v 0.        (1. -. f) 1.       1.
  | 4. -> Gg.Color.v f         0.       1.       1.
  | 5. -> Gg.Color.v 1.        0.       (1. -. f) 1.
  | _ -> assert false

let hue h = hue_pct(h *. 360.)


(* FIXME: generate color ranges between arbitrary colors.  *)
let range a b n =
  let d1 = 1. /. float(n - 1) in
  let dx = (b -. a) *. d1 in
  let l = ref [] in
  for i = n - 1 downto 0 do
    l := (a +. float i *. dx,  hue_pct(float i *. d1)) :: !l
  done;
  !l




module Palette = struct
  include Color_brewery_palettes (* Generated by make_brewer.ml *)
  (* The important types are defined in the included module. *)

  let length m = m.length

  let rgb_exn m n =
    if n <= 0 then []
    else if n > m.length then invalid_arg "Color_brewery.Palette.rgb"
    else m.rgb.(n)

  let cmyk_exn m n =
    if n <= 0 then []
    else if n > m.length then invalid_arg "Color_brewery.Palette.cmyk"
    else m.cmyk.(n)


  let satisfy specified prop =
    match specified with
    | `Yes -> (match prop with
               | `Yes -> true
               | `No | `Maybe -> false)
    | `Maybe -> (match prop with
                 | `Yes | `Maybe -> true
                 | `No -> false)
    | `No -> true

  let find ?ty ?(blind = `No) ?(print = `No) ?(copy = `No)
        ?(lcd = `No) length =
    if length <= 0 then []
    else (
      let is_of_type = match ty with
        | Some ty -> (fun m -> m.ty = ty)
        | None -> (fun _ -> true) in
      let filter m =
        m.length >= length
        && is_of_type m
        && satisfy blind m.blind.(length)
        && satisfy print m.print.(length)
        && satisfy copy m.copy.(length)
        && satisfy lcd m.screen.(length) in
      List.filter filter all_maps
    )
end
