type color = Gg.color
type cmyk = Gg.v4

let to_hex x =
  if x <= 0. then 0
  else if x >= 1. then 0xFF
  else truncate(x *. 255. +. 0.5)

let to_int c =
  (to_hex(Gg.Color.r c) lsl 16) lor (to_hex(Gg.Color.g c) lsl 8)
  lor (to_hex(Gg.Color.b c))


let hue_pct h =
  (* h ∈ [0, 1[ instead of the usual h ∈ [0, 360[. *)
  let f, hi = modf (abs_float h *. 6.) in
  match mod_float hi 6. with
  | 0. -> Gg.Color.v 1.        f        0.       1. (* alpha = 1 *)
  | 1. -> Gg.Color.v (1. -. f)  1.       0.       1.
  | 2. -> Gg.Color.v 0.        1.       f        1.
  | 3. -> Gg.Color.v 0.        (1. -. f) 1.       1.
  | 4. -> Gg.Color.v f         0.       1.       1.
  | 5. -> Gg.Color.v 1.        0.       (1. -. f) 1.
  | _ -> assert false

let hue h = hue_pct(h *. 360.)


(* FIXME: generate color ranges between arbitrary colors.  *)
let range a b n =
  let d1 = 1. /. float(n - 1) in
  let dx = (b -. a) *. d1 in
  let l = ref [] in
  for i = n - 1 downto 0 do
    l := (a +. float i *. dx,  hue_pct(float i *. d1)) :: !l
  done;
  !l




module Palette = struct
  include Color_brewery_palettes (* Generated by make_brewer.ml *)
  (* The important types are defined in the included module. *)

  let length m = m.length

  let rgb_exn m n =
    if n <= 0 then []
    else if n > m.length then invalid_arg "Color_brewery.Map.rgb"
    else m.rgb.(n)

  let cmyk_exn m n =
    if n <= 0 then []
    else if n > m.length then invalid_arg "Color_brewery.Map.cmyk"
    else m.cmyk.(n)

  (* FIXME: add more characteristics to the colors & then more filter
     options. *)
  let find ?ty length =
    let filter = match ty with
      | Some ty -> (fun m -> m.length = length && m.ty = ty)
      | None -> (fun m -> m.length = length) in
    List.filter filter all_maps
end
